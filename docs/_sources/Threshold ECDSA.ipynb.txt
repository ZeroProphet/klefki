{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Threshold ECDSA\n",
    "====================="
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Threshold signature schemes enable sharing signing power amongst n parties such that any subset of t + 1 can jointly sign, but any smaller subset cannot.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## I Model, Definitions and Tools"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.1 Model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### **Communication Model**\n",
    "\n",
    "We assume that our computation model is composed of a set of $n$ players $P_1,\\cdots, P_n$ connected by a complete network of point-to-point channels and a broadcast channel.\n",
    "\n",
    "### **The Adversary**\n",
    "\n",
    "We assume that an adversary, $A$, can corrupt up to $t$ of the $n$ players in the network. $A$ learns all the information stored at the corrupted nodes, and hears all the broadcasted messages. We consider two type of adver saries:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.2 Deﬁnitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### **Signature Scheme**\n",
    "\n",
    "A signature scheme $S$ is a triple of eﬃcient randomized algorithms $(Key-Gen, Sig, Ver)$.\n",
    "\n",
    "* **Key-Gen** is the key generator algorithm.\n",
    "\n",
    "    on input the security parameter $1^\\lambda$ , it outputs a pair $(y, x)$, such that $y$ is the public key and $x$ is the secret key of the signature scheme.\n",
    "\n",
    "* **Sig** is the signing algorithm: \n",
    "\n",
    "    on input a message m and the secret key $x$, it outputs $sig$, a signature of the message $m$. \n",
    "\n",
    "    Since $Sig$ can be a randomized algorithm there might be several valid signatures $sig$ of a message $m$ under the key $x$; with $Sig(m, x)$ we will denote the set of such signatures\n",
    "\n",
    "* **Ver** is the veriﬁcation algorithm.\n",
    "    \n",
    "    On input a message $m$, the public key $y$, and a string $sig$, it checks whether $sig$ is a proper signature of $m$, i.e. if $sig \\in Sig(m, x)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Threshold secret sharing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Given a secret value $x$ we say that the values $(x_1 , \\cdots , x_n)$ constitute a $(t, n)$-threshold secret sharing of $x$ if $t$ (or less) of these values reveal no information about $x$, and if there is an eﬃcient algorithm that outputs $x$ having $t + 1$ of the values $x_i$ as inputs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Threshold signature schemes."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let $S=(Key-Gen, Sig, Ver)$ be a signature scheme. A $(t, n)$-threshold signature scheme $TS$ for $S$ is a pair of protocols $(Thresh-Key-Gen, Thresh-Sig)$ for the set of players $P_1 , \\cdots, P_n$ ."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Thresh-Key-Gen** is a distributed key generation protocol used by the players to jointly generate a pair $(y, x)$ of public/private keys on input a security parameter $1^\\lambda$ .\n",
    "\n",
    "* **Thresh-Sig** is the distributed signature protocol. The private input of $P_i$ is the value $x_i$ . The public inputs consist of a message m and the public key $y$. The output of the protocol is a value $sig \\in Sig(m, x)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.3 Tools"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Additively Homomorphic Encryption"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We assume the existence of an encryption scheme E which is additively homo- morphic modulo a large integer $N$, One instantiation of a scheme with these properties is **Paillier’s encryption scheme**.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With $\\oplus_{i=1}^{t+1}$a_i, we denote the summation over the addition operation $+_E$ of the encryption scheme:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$\n",
    "\\oplus_{i=1}^{t+1}a_i = a_1 +_E a_2 +_E \\cdots +_E a_{t+1}\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Threshold Cryptosystems"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In a $(t, n)$-threshold cryptosystem, there is a public key $pk$ with a matching secret key $sk$ which is shared among $n$ players with a $(t, n)$-secret sharing.\n",
    "\n",
    "When a message $m$ is encrypted under $pk$, $t+1$ players can decrypt it via a communication protocol that does not expose the secret key."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "More formally, a public key cryptosystem $\\epsilon$ is deﬁned by three eﬃcient algorithms:\n",
    "\n",
    "- key generation **Enc-Key-Gen** that takes as input a security parameter $λ$, and outputs a public key $pk$ and a secret key $sk$.\n",
    "\n",
    "\n",
    "- An encryption algorithm **Enc** that takes as input the public key $pk$ and a message $m$, and outputs a ciphertext $c$. Since **Enc** is a randomized algorithm, there will be several valid encryptions of a message $m$ under the key $pk$; with $Enc(m, pk)$ we will denote the set of such ciphertexts.\n",
    "\n",
    "\n",
    "- And a decryption algorithm Dec which is run on input $c$, $sk$ and outputs $m$, such that $c \\in Enc(m, pk)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A $(t, n)$ threshold cryptosystem $T\\epsilon$, consists of the following protocols for $n$ players $P_1 , \\cdots , P_n$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- A key generation protocol **TEnc-Key-Gen** that takes as input a security parameter $\\lambda$, and the parameter $t, n$, and it outputs a public key $pk$ and a vector of secret keys $(sk_1, \\cdots, sk_n)$ where $sk_i$ is private to player $P_i$ . This protocol could be obtained by having a trusted party run Enc-Key-Gen and sharing sk among the players.\n",
    "\n",
    "\n",
    "- A threshold decryption protocol **TDec**, which is run on public input a ciphertext $c$ and private input the share $sk_i$ . The output is $m$, such that $c\\in Enc(m, pk)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Threshold variations of Paillier’s scheme have been presented in the literature:\n",
    "\n",
    "* O. Baudron, P.-A. Fouque, D. Pointcheval, G. Poupard and J. Stern. Practical Multi-Candidate Election System. PODC’01\n",
    "\n",
    "* I. Damg˚ard and M. Jurik. A Generalisation, a Simpliﬁcation and Some Appli- cations of Paillier’s Probabilistic Public-Key System. PKC’01, LNCS Vol.1992, pp.119–136\n",
    "\n",
    "* I. Damg˚ard, M. Koprowski: Practical Threshold RSA Signatures without a Trusted Dealer. EUROCRYPT 2001: LNCS Vol.2045, pp. 152-165\n",
    "\n",
    "* C. Hazay, G.L. Mikkelsen, T. Rabin, T. Toft. and A.A. Nicolosi: Eﬃcient RSA key generation and threshold Paillier in the two-party setting."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Independent Trapdoor Commitments"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A trapdoor commitment scheme allows a sender to commit to a message with information-theoretic privacy."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A (non-interactive) **trapdoor commitment scheme** consists of four algorithms $KG, Com, Ver, Equiv$ with the following properties:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- $KG$ is the key generation algorithm, on input the security parameter it outputs a pair $pk, tk$ where $pk$ is the public key associated with the commitment scheme, and $tk$ is called the **trapdoor**."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- $Com$ is the commitment algorithm. On input pk and a message M it outputs $[C(M), D(M)] = Com(pk, M, R)$ where $r$ are the coin tosses. $C(M)$ is the commitment string, while $D(M)$ is the decommitment string which is kept secret until opening time."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* $Ver$ is the veriﬁcation algorithm. On input $C, D$ and $pk$ it either outputs a message M or $\\bot$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* $Equiv$ is the algorithm that opens a commitment in any possible way given the trapdoor information. It takes as input $pk$, strings $M, R$ with $[C(M), D(M)] = Com(pk, M, R)$, a message $M' \\neq M$ and a string $T$. If $T = tk$ then $Equiv$ outputs $D'$ such that $Ver(pk, C(M), D') = M'$ ."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We note that if the sender refuses to open a commitment we can set $D = \\bot$ and $Ver(pk, C, \\bot) = \\bot$. Trapdoor commitments must satisfy the following properties:\n",
    "\n",
    "* **Correctness:**\n",
    "\n",
    "     If $[C(M), D(M)] = Com(pk, M, R)$ then $Ver(pk, C(M), D(M)) = M$.\n",
    "\n",
    "\n",
    "* **Information Theoretic Security:**\n",
    "\n",
    "     For every message pair $M, M'$ the distributions $C(M$) and $C(M')$ are statistically close.\n",
    "\n",
    "\n",
    "* **Secure Binding:**\n",
    "\n",
    "    We say that an adversary $A$ wins if it outputs $C, D, D'$ such that $Ver(pk, C, D) = M, Ver(pk, C, D') = M'$ and $M \\neq M'$ . We require that for all eﬃcient algorithms $A$, the probability that $A$ wins is negligible in the security parameter.\n",
    "    \n",
    "* **Independence:**\n",
    "\n",
    "    if the honest parties open their commitments in diﬀerent ways using the trapdoor, the adversary cannot change the way he opens his commitments C_j based on the honest parties’ opening."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## II  Scheme of GG16"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initialization phase"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this phase, a common reference string containing the public information $pk$ for an independent trapdoor commitment $KG$, $Com$, $Ver$, $Equiv$ is selected and published. This could be accomplished by a trusted third party, who can be assumed to erase any secret information (i.e. the trapdoor of the commitment) after selection.\n",
    "\n",
    "The common parameters $G, g, q$ for the DSA scheme are assumed to be known.\n",
    "\n",
    "\n",
    "\n",
    "---------------"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Key generation protocol"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from zkp_playground.types.algebra.concrete import EllipticCurveCyclicSubgroupSecp256k1 as ECC\n",
    "from zkp_playground.types.algebra.concrete import EllipticCurveGroupSecp256k1 as Cruve\n",
    "from zkp_playground.types.algebra.concrete import FiniteFieldCyclicSecp256k1 as CF\n",
    "from zkp_playground.types.algebra.concrete import FiniteFieldSecp256k1 as F\n",
    "from zkp_playground.zkp.pedersen import PedersonCommitment\n",
    "from zkp_playground.types.algebra.utils import randfield\n",
    "from zkp_playground.bitcoin.address import gen_address"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here we describe how the players can jointly generate a DSA key pair $(x, y = g_x)$ with $y$ public and $x$ shared among the players."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The idea is to generate a public key $E$ for an additively $(\\mod N)$ homomorphic encryption scheme $E$, together with the secret key $D$ in shared form among the players."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The value $N$ is is chosen to be larger than $q^8$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from zkp_playground.crypto.paillier import Paillier\n",
    "from zkp_playground.zkp.pedersen import PedersonCommitment, com as commit\n",
    "from functools import partial\n",
    "from zkp_playground.types.algebra.concrete import FiniteFieldCyclicSecp256k1 as CF\n",
    "from zkp_playground.numbers.primes import generate_prime\n",
    "from functools import reduce\n",
    "from operator import mul, add"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "q = CF(CF.P)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "P = generate_prime(1024)\n",
    "Q = generate_prime(1024)\n",
    "Pai = Paillier(P, Q)\n",
    "E, D = Pai.E, Pai.D"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then a value $x$ is generated, and encrypted with E, with the value $α = E(x)$ made public.\n",
    "\n",
    "Note that this is an implicit $(t, n)$ secret sharing of $x$, since the decryption key of $E$ is shared among the players."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- Each player $P_i$ selects a random value $x_i ∈ Z_q$ , computes $y_i$ = $g^{x_i} ∈ G$ and $[C_i , D_i ] = Com(y_i)$;"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "G = ECC.G\n",
    "n = 3\n",
    "xs = [randfield(CF) for _ in range(n)]\n",
    "ys = [G ** x for x in xs]\n",
    "\n",
    "trap = randfield(CF)\n",
    "H = G ** trap\n",
    "com = partial(PedersonCommitment, H=H, G=G)\n",
    "\n",
    "coms = [com(x=y.value[0], r=y.value[1]) for y in ys]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = reduce(add, xs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- Each player $P_i$ broadcast $C_i$\n",
    "    * $D_i$ which allows everybody to compute $y_i = Ver(C_i , D_i )$\n",
    "    * $\\alpha_i=E(x_i);$\n",
    "    * a ZK argument $\\Pi_i$ that states\n",
    "        * $\\exists \\mu=y_i$\n",
    "        * $D(a_i)=\\mu$\n",
    "        \n",
    "      If any of the ZK arguments fails, the protocol terminates."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "all([c.C == commit(H=H, G=G, *c.D) for c in coms])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "from operator import mul\n",
    "from zkp_playground.types.algebra.meta import field"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "from operator import add\n",
    "from functools import reduce\n",
    "\n",
    "alpha = reduce(mul, [E(x.value) for x in xs])\n",
    "y = reduce(add, ys)\n",
    "FN = alpha.functor"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(alpha)) == reduce(add, xs) == x\n",
    "assert G ** CF(D(alpha)) == y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- The players compute $\\alpha=\\oplus_{i=1}^{t+1}a_i$ and $y=\\sum_{i=1}^{t+1}y_i$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Signature Generation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The signature generation protocol is run on input $m$ (the hash of the message $M$ being signed)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "from zkp_playground.utils import to_sha256int\n",
    "\n",
    "m = CF(to_sha256int(\"Hello Threshold ECDSA\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 1\n",
    "\n",
    "Each player $P_i$\n",
    "    \n",
    "1. choose $\\rho_i \\leftarrow Z_q$\n",
    "\n",
    "2. compute $u_i=E(\\rho_i)$ and $v_i=p_i \\times_E\\alpha = E(\\rho_ix)$\n",
    "\n",
    "3. compute $[C_{1,i}, D_{i,i}]=Com([u_i, v_i])$ and broadcast $C_{1,i}$\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "ps = [randfield(CF) for _ in range(n)]\n",
    "us = [E(p) for p in ps]\n",
    "vs = [alpha ** p for p in ps]\n",
    "\n",
    "coms1 = [com(x=t[0], r=t[1]) for t in zip(us, vs)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each player $P_i$ broadcasts:\n",
    "   \n",
    "* $D_{1,i}$. This allow everybody to compute $[u_i, v_i]=Ver(C_{1,i}, D_{1,i})$\n",
    "\n",
    "* a zero-knowledge argument $\\Pi_{1,i}$ which states\n",
    "\n",
    "    - $\\exists \\eta \\in [-q^3,q^3]$ such that\n",
    "    \n",
    "        $D(u_i)=\\eta$\n",
    "        \n",
    "        $D(v_i)=\\eta D(E(x)$\n",
    "        \n",
    "        \n",
    "Players compute $u=\\oplus_{i=1}^{t+1}u_i=E(\\rho)$ and $v=\\oplus_{i=1}^{t+1}v_i=E(\\rho x)$, where $\\rho=\\sum_{i=1}^{1+1}\\rho_i$\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "all([c.C == commit(H=H, G=G, *c.D) for c in coms1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "u = reduce(mul, us)\n",
    "v = reduce(mul, vs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(u)) == reduce(add, (ps))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "assert CF(D(alpha ** ps[1])) == x * ps[1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(alpha ** ps[0] * alpha ** ps[1] * alpha ** ps[2])) == x * (ps[0] + ps[1] + ps[2]) == CF(D(v))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(v)) == CF(D(E(reduce(add, ps) * x)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each player $P_i$\n",
    "\n",
    "- choose $k_i \\in Z_q$ and $c_i \\in R[-q^6, q^6]$\n",
    "- computes $r_i=g^{k_i}$ and $w_i=(k_i\\times_E u) +_E E(c_iq)=E(k_i\\rho+c_iq))$\n",
    "- computes $[C_{2,i},D_{2_i}=Com(r_i,w_i)$ and broadcast $C_{2i}$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "ks = [randfield(CF) for _ in range(n)]\n",
    "rs = [G**k for k in ks]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "cs = [randfield(CF) for _ in range(n)]\n",
    "ws = [(u ** k) * E(c*q) for c, k in zip(cs, ks)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "coms2 = [com(x=c, r=w) for c, w in zip(cs, ws)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "dcoms2 = [c.D for c in coms]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "CF(D(u ** ks[0])) == reduce(add, (ps)) * ks[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "CF(D(u ** ks[0] * E(cs[0] * q))) == CF(D(u ** ks[0]) + D(E(cs[0] * q))) \\\n",
    "                                 == reduce(add, (ps)) * ks[0] + cs[0] * q"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each player P_i broadcasts\n",
    "\n",
    "1. $D_{2,i}$, which allows everybody to compute $[r_i , w_i ]$ = $Ver(C_{2,i} , D_{2,i} )$\n",
    "    \n",
    "2. a zero-knowledge argument $Π_{(2,i)}$\n",
    "    \n",
    "Players compute $w=\\oplus_{i=1}^{t+1}w_i=E(k\\rho + cq)$ where $k=\\sum_{i=1}^{t+1}k_i$ and $c=\\sum_{i=1}^{t+1}c_i$. Players also compute $R=\\Pi_i^{t+1}r_i=g^k$ and $r=H'(R)\\in Z_q$\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "all([c.C == commit(H=H, G=G, *c.D) for c in coms2])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "w = reduce(mul, ws)\n",
    "R = reduce(mul, rs)\n",
    "r = CF(R.x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "R == G ** reduce(add, ks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "CF(D(w)) == reduce(add, (ps)) * reduce(add, ks) + reduce(add, cs) * q"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 5\n",
    "\n",
    "players jointly decrypt $w$ using **TDec** to learn the value $\\tau ∈ [−q^7 , q^7]$ such that $\\tau = kρ \\mod q$ and $ψ = η ^{−1} \\mod q$\n",
    "\n",
    "Each player computes:\n",
    "\n",
    "\n",
    "\\begin{align}\n",
    "\\sigma &= \\psi \\times_E [m\\times_E u]+_E(r\\times_E v)]\\\\\n",
    "&= \\psi \\times_E [E(m\\rho) +_E E(r \\rho x)]\\\\\n",
    "&= (k^{-1\\rho^{-1}}\\times_E [E(\\rho (m+xr)) \\\\\n",
    "&=E(k^{-1}(m+xr))\\\\\n",
    "&=E(s)\n",
    "\\end{align}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "psi = CF(D(w))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "pai = ~psi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "sigma = ((u**m) * (v**r)) ** pai"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = reduce(add, xs)\n",
    "p = reduce(add, ps)\n",
    "k = reduce(add, ks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(u**m)) == m * p\n",
    "assert CF(D(v**r)) == r * p * x\n",
    "assert CF(D(u**m)) + CF(D(v**r)) == p * (m + x * r)\n",
    "assert CF(D((u**m) * (v**r))) == p * (m + x * r)\n",
    "assert CF(D(((u**m) * (v**r)) ** pai)) == (m + x * r)/k"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(sigma)) == (m + x * r)/k\n",
    "assert (G ** k).x == r"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 6\n",
    "\n",
    "The players invoke distributed decryption protocol TDec over the ciphertext $σ$. Let $s = D(σ) mod q$. The players output $(r, s)$ as the signature for $m$.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "r, s = r, CF(D(sigma))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Verify"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "from zkp_playground.crypto.ecdsa.secp256k1 import verify"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "verify(pub=y, sig=(r, s), msg=\"Hello Threshold ECDSA\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## III Scheme of GG18"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A share conversion protocol"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Assume that we have two parties Alice and Bob holding two secrets $a, b \\in Z_q$ respectively which we can think of as multiplicative shares of a secret $x = ab \\mod q$. Alice and Bob would like to compute secret additive shares $α, β$ of $x$, that is random values such that $α + β = x = ab \\mod q$ with Alice holding $a$ and Bob holding $b$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here we show a protocol based on an additively homomorphic scheme. We assume that Alice is associated with a public key $E_A$ for an additively homomorphic scheme $E$ over an integer $N$. Let $K > q$ also be a bound which will be speciﬁed later."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The players run on input $G$, $g$ the cyclic group used by the DSA signature scheme. We assume that each player $P_i$ is associated with a public key $E_i$ for an additively homomorphic encryption scheme $E$. In our protocol we also assume that $B = g^b$ might be public."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "###### MtA (for Multiplicative to Additive)\n",
    "###### MtAwc (as MtA “with check”)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "from zkp_playground.crypto.paillier import Paillier\n",
    "from zkp_playground.numbers.primes import generate_prime\n",
    "from zkp_playground.types.algebra.meta import field\n",
    "from zkp_playground.types.algebra.utils import randfield\n",
    "from zkp_playground.types.algebra.concrete import EllipticCurveCyclicSubgroupSecp256k1 as ECC\n",
    "from zkp_playground.types.algebra.concrete import EllipticCurveGroupSecp256k1 as Cruve\n",
    "from zkp_playground.types.algebra.concrete import FiniteFieldCyclicSecp256k1 as CF\n",
    "from zkp_playground.zkp.pedersen import PedersonCommitment\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "Pai_A = Paillier(generate_prime(32), generate_prime(32))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "F_q = field(generate_prime(32), \"q\")\n",
    "F_n = field(Pai_A.N)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "a, b = randfield(F_q), randfield(F_q)\n",
    "ab = a * b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Step 1**\n",
    "\n",
    "Alice initiates the protocol by\n",
    "\n",
    " \n",
    " - sending $c_A=E_A(a)$ to Bob.\n",
    " - proving in ZK that $a < K$ via a range proof."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "c_a = Pai_A.E(a)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Step 2**\n",
    "\n",
    "\n",
    "Bob computes the ciphertext $c_B=b \\times_E c_A +_E E_A(\\beta') = E_A(ab + \\beta')$ where $\\beta'$ is chosen uniformly at random in $Z_N$. Bob sets his share to $\\beta = -\\beta' \\mod q$. He responds to Alice by\n",
    "\n",
    "\n",
    "- sending $c_B$\n",
    "- proving in ZK that $b < K$\n",
    "- only if $B=g^b$ is public proving in ZK that he knoows $b, \\beta'$ s.t. $B=g^b$ and $c_B=b\\times_E c_A +_E E_A(\\beta')$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "beta_ = randfield(F_q)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert F_q(Pai_A.D(Pai_A.E(beta_) * c_a ** b)) == F_q(Pai_A.D(Pai_A.E(a*b + beta_)))\n",
    "c_b = Pai_A.E(beta_) * c_a ** b"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "beta = F_q(-beta_)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Step 3**\n",
    "\n",
    "\n",
    "Alice decrypts $c_B$ to obtain $\\alpha$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "alpha = F_q(Pai_A.D(c_b))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert alpha + beta == a*b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Implementation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "from functools import partial\n",
    "from zkp_playground.numbers import length\n",
    "\n",
    "def MtA(a, b=None, p=None, q=None):\n",
    "    if not (p and q):\n",
    "        p, q = generate_prime(128), generate_prime(128)\n",
    "    if not b:\n",
    "        return partial(MtA, a=a)\n",
    "    assert length(a.P) < length(p*q)\n",
    "    Pai_A = Paillier(p, q)\n",
    "    F_n = field(Pai_A.N)\n",
    "    F_q = a.functor\n",
    "    c_a = Pai_A.E(a)\n",
    "    beta_ = randfield(F_q)\n",
    "    beta =  F_q(-beta_)\n",
    "    c_b = Pai_A.E(beta_) * c_a ** b\n",
    "    alpha = F_q(Pai_A.D(c_b))\n",
    "    assert a * b == alpha + beta\n",
    "    return alpha, beta\n",
    "    \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(FiniteField::100, FiniteField::143)"
      ]
     },
     "execution_count": 49,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "RF = field(generate_prime(8))\n",
    "a, b = randfield(RF), randfield(RF)\n",
    "MtA(a)(b=b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Key generation Protocol\n",
    "\n",
    "* **Phase 1**. Each Player $P_i$ select $u_i \\in_R Z_q$; computes $[KGC_i, KGD_i]=Com(g^{u_i})$ and broadcast $KGC_i$. Each player $P_i$ broadcast $E_i$ the public key for Paillier' cryptosytem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [],
   "source": [
    "n = 9\n",
    "t = 6\n",
    "G = ECC.G\n",
    "\n",
    "p = generate_prime(128)\n",
    "q = generate_prime(128)\n",
    "pai = Paillier(p, q)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [],
   "source": [
    "pai_pks = [Paillier(p, q) for _ in range(n)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "us = [randfield(CF) for _ in range(n)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [],
   "source": [
    "ys = [G ** u for u in us]\n",
    "\n",
    "trap = randfield(CF)\n",
    "H = G ** trap\n",
    "com = partial(PedersonCommitment, H=H, G=G)\n",
    "coms = [com(x=y.value[0], r=y.value[1]) for y in ys]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Phase 2**. Each Player $P_i$ broadcast $KCD_i$, let $y_i$ be the value decommitted by $P_i$. The player $P_i$ performs a $(t, n)$ Feldman-VSS of the value $u_i$, with $y_i$ as the \"free term in the exponent\". The pubkey is set to $y=\\prod_i y_i$. Each player adds the private shares received during the $n$ VSS. The resoulting values $x_i$ are a $(t, n)$ SSSS of secret key $x = \\sum_iu_i$. Note that the value $X_i=g^x_i$ are public."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "from zkp_playground.crypto.vss import VSS\n",
    "from zkp_playground.types.algebra.concrete import FiniteFieldCyclicSecp256k1 as CF\n",
    "from zkp_playground.types.algebra.concrete import EllipticCurveCyclicSubgroupSecp256k1 as ECC\n",
    "from functools import reduce\n",
    "from operator import mul, add"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "vss = [VSS(CF, ECC.G).setup(u, t, n) for u in us]\n",
    "assert len(vss) == n\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "ids = [randfield(CF) for i in range(n)]\n",
    "vss_shares = [(CF(i), reduce(add, [v.f(i) for v in vss])) for i in ids]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs = [i[1] for i in vss_shares]\n",
    "ids = [i[0] for i in vss_shares]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = reduce(add, us)\n",
    "y = reduce(mul, ys)\n",
    "assert G ** x == y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert x == VSS.decrypt(vss_shares)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Phase 3**, let $N_i=p_iq_i$ be the RSA mod associated with E_i, Each palyer $P_i$ proves in ZK that he knows $x_i$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Signature Generation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Prepare**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using the appropriate Lagrangian coeﬃcients $\\lambda_{i,S}$ each player in $S$ can locally map its own $(t, n)$ share of $x_i$ of x into a $(t, t)$ share of $x$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$\n",
    "x = \\sum_{j=0}^{k-1}f(x_i)\\prod_{j=0;i\\neq j}^{k-1}\\frac{{x_m}}{{x_j}-{x_i}}\n",
    "$$\n",
    "\n",
    "$$\n",
    "m_i = f(x_i)\\prod_{i=0;j\\neq j}^{k-1}\\frac{{x_m}}{{x_j}-{x_i}}\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [],
   "source": [
    "ws = [xs[j] * reduce(mul, [ids[m] / (ids[m]-ids[j]) for m in range(t) if m != j]) for j in range(t)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert x == reduce(add, ws)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will to sign msg $m$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "from zkp_playground.utils import to_sha256int\n",
    "\n",
    "m = CF(to_sha256int(\"Hello Threshold ECDSA\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Phase1**. \n",
    "\n",
    "Each Player $P_i$ selects $k_i, \\gamma_i \\in_R Z_q$; computes $[C_i, D_i]=Com(G^{\\gamma_i})$ and broad cast $C_i$. Define $k=\\sum_{i \\in s}k_i, \\gamma = \\sum_{i \\in s}\\gamma_i$. Note that\n",
    "\n",
    "$$\n",
    "k{\\gamma}=\\sum_{i, j \\in S}k_i \\gamma_j \\mod q \\\\\n",
    "kx = \\sum_{i, j \\in S} k_i w_i \\mod q\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "ks = [randfield(CF) for _ in range(t)]\n",
    "rs = [randfield(CF) for _ in range(t)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "k = reduce(add, ks)\n",
    "r = reduce(add, rs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Phase2**. \n",
    "\n",
    "Every pair of player $P_i, P_j$ engages in two $multiplicative-to-additive$ share conversation subprotocols\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- 2.1 $P_i, P_j$ run $MtA$ with shares $k_i, \\gamma_j$ respectively. Let $\\alpha_{ij}$ [resp. $\\beta_{ij}$] be the share received by player $P_i$ [resp. $P_j$] at the end of this protocol, i.e.\n",
    "\n",
    "$$\n",
    "k_i\\gamma_j = \\alpha_{ij}+\\beta_{ij}\n",
    "$$\n",
    "\n",
    "Player $P_i$ set $\\delta_i = k_i\\gamma_i + \\sum_{j\\neq i}\\alpha_{ij}+\\sum_{j\\neq i}\\beta_{ij}$. Note that the $\\delta_i$ are a $(t, t)$ additive sharing of $k\\gamma=\\sum_{i \\in s} \\delta_i$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "p = generate_prime(512)\n",
    "q = generate_prime(512)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "PMtA = partial(MtA, p=p, q=q)\n",
    "shares_kg = [\n",
    "    [PMtA(a=ks[i], b=rs[j]) for j in range(t) if j != i]\n",
    "for i in range(t)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "ds = [ks[i]*rs[i] + reduce(add, [s[0] + s[1] for s in shares_kg[i]]) for i in range(t)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert k * r == reduce(add, ds)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- 2.2 $P_i,P_j$ run MtAwc with shares $k_i, w_i$ respectively. Let $\\mu_{ij}$ [resp. $v_{ij}$] be the share received by player $P_i$[resp. $P_j$] at the end of this protocol, i.e.\n",
    "\n",
    "$$\n",
    "k_iw_i = \\mu_{ij} + v_{ij}\n",
    "$$\n",
    "\n",
    "Player $P_i$ sets $\\sigma_i = k_iw_i + \\sum_{j\\neq i}\\mu_{ij}+\\sum_{j\\neq i}v_{ij}$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "p = generate_prime(512)\n",
    "q = generate_prime(512)\n",
    "PMtA = partial(MtA, p=p, q=q)\n",
    "shares_kw = [\n",
    "    [PMtA(a=ks[i], b=ws[j]) for j in range(t) if j != i]\n",
    "for i in range(t)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "sigmas = [ks[i] * ws[i] + reduce(add, [s[0] + s[1] for s in shares_kw[i]]) for i in range(t)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert k * x == reduce(add, sigmas)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Phase 3** "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Every player $P_i$ broadcasts $\\delta_i$ and the players reconstruct $\\delta = \\sum_{i \\in s} \\delta_i = k\\gamma$. The players compute $\\delta^{−1} \\mod q$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [],
   "source": [
    "d = reduce(add, ds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [],
   "source": [
    "d_ = ~d"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Phase 4**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each Player $P_i$ broadcasts $D_i$, let $\\Gamma_i$ be the value decommited by $P_i$ who proves in $ZK$ that he knows $\\gamma_i$ s.t. $\\Gamma_i = g^{\\gamma_i}$ using Schnoor's protocol."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The players compute\n",
    "\n",
    "$$\n",
    "R = \\left[\\prod_{i\\in S}\\Gamma_i\\right]^{-1} = g^{(\\sum_{i\\in S}\\gamma_i)k^{-1}\\gamma^{-1}}=g^{\\gamma k^{-1}\\gamma^{-1}}=g^{k^{-1}}\n",
    "$$\n",
    "\n",
    "and $r = R.x$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert k * r == reduce(add, ds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 75,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reduce(add, ds) * (~r) == k"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [],
   "source": [
    "com_rs = [G**r for r in rs]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [],
   "source": [
    "R = reduce(mul, com_rs) ** d_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert R == G ** (~k)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "r = CF(R.x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Phase 5**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each Player $P_i$ sets $s_i=mk_i+r\\sigma_i$. Note that\n",
    "\n",
    "$$\n",
    "\\sum_{i\\in S} s_i = m \\sum_{i \\in s}k_i + r\\sum_{i\\in S}\\sigma_i=mk + rkx = k(m+xr)=s\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert G ** x == y\n",
    "assert k * x == reduce(add, sigmas)\n",
    "assert k == reduce(add, ks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert m * reduce(add, ks) + reduce(add, sigmas) * r == k * (m + x * r)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "ss = [m * ks[i] + sigmas[i] * r for i in range(t)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = reduce(add, ss)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 84,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "s == k * (m + x * r)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Verify"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "from zkp_playground.crypto.ecdsa.secp256k1 import verify"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "verify(pub=y, sig=(r, s), msg=\"Hello Threshold ECDSA\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Ref:\n",
    "\n",
    "* Antonio Salazar Cardozo, Threshold ECDSA — Safer, more private multi-signatures, https://blog.keep.network/threshold-ecdsa-safer-more-private-multi-signatures-51153f3e9ed2\n",
    "\n",
    "* Gennaro, Rosario, Steven Goldfeder, and Arvind Narayanan. “Threshold-Optimal DSA/ECDSA Signatures and an Application to Bitcoin Wallet Security.” In Applied Cryptography and Network Security, edited by Mark Manulis, Ahmad-Reza Sadeghi, and Steve Schneider, 9696:156–74. Cham: Springer International Publishing, 2016. https://doi.org/10.1007/978-3-319-39555-5_9.\n",
    "\n",
    "* Rosario Gennaro and Steven Goldfeder. 2018. Fast Multiparty Threshold ECDSA with Fast Trustless Setup. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (CCS ’18). Association for Computing Machinery, New York, NY, USA, 1179–1194. DOI:https://doi.org/10.1145/3243734.3243859\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
